---
layout: post
comments: true
title: LightOJ 1003 Drunk
category: 算法
tags: 
keywords:
description: 
use_math: true
---

* content
{:toc}

![1003](http://img.blog.csdn.net/20150330170137245)

思路：拓扑排序（有向图的环路检测）。将所有的名称构建一个有向图，比如“soda wine”就是起点为“soda”，终点为“wine”的一条有向边。然后对图进行深度优先搜索，如果发现环路，则说明是可以“get drunk”的(Yes)，否则不能(No)。

需要注意的点：
1. 读入数据的效率，即如何将一个名字与一个节点一一对应（对出现的名字进行不重复的编号）。如果采用数组去存名字，每读入一个名字就去查这个数组来判断这个名字之前是否出现过，那将是十分低效的，甚至会导致超时。因为边的数量最多可以到20000，在最坏的情况下，节点的数量可以达到10000。在这个问题上，hash map有得天独厚的优势，而STL的map容器提供了这种数据结构。
2. 存图的方式。如果采用邻接矩阵存图，由于最坏情况下节点数量可以达到10000，所以邻接数组的规模不能小于10000*10000，这样是会爆空间的。所以应该采用邻接表来存图。

### AC代码：
```c++
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <map>
using namespace std;

#define MAX 10001  //最大边数
#define INF 999999

int n=1, m;
int u[MAX], v[MAX], first[2*MAX], next[2*MAX];
int visit[2*MAX];
map<string, int> mapName;

void readGraph()
{
    string name1, name2;
    int i;
    pair<map<string, int>::iterator, bool> insert_pair;
    map<string, int>::iterator iter;
    scanf("%d", &m);
    for(i = 1; i <= 2*MAX-1; ++i) first[i] = -1;
    for(i = 1; i <= m; ++i) {
        cin>>name1>>name2;
        iter = mapName.find(name1);
        if(iter != mapName.end()) { //找到该名字
            u[i] = iter->second;
        }
        else {
            mapName.insert(pair<string, int>(name1, n));
            u[i] = n;
            ++n;
        }
        iter = mapName.find(name2);
        if(iter != mapName.end()) {
            v[i] = iter->second;
        }
        else {
            mapName.insert(pair<string, int>(name2, n));
            v[i] = n;
            ++n;
        }
        //下面这两行是用数组构建邻接表的关键
        next[i] = first[u[i]];
        first[u[i]] = i;
    }
}

bool DFS(int pos)
{
    int k, l;
    visit[pos] = -1;
    k = first[pos];
    if(k != -1) {
        if(visit[v[k]] < 0) return false;
        else if(!visit[v[k]] && !DFS(v[k])) return false;
        l = next[k];
        while(l != -1) {
            if(visit[v[l]] < 0) return false;
            else if(!visit[v[l]] && !DFS(v[l])) return false;
            l = next[l];
        }
    }
    visit[pos] = 1;
    return true;
}

bool topoSort()
{
    memset(visit, 0, sizeof(visit));
    for(int i = 1; i <= n; ++i) {
        if(!visit[i]) {
            if(!DFS(i))
                return false;
        }
    }
    return true;
}

int main()
{
    int cases, casenum=0;
    scanf("%d", &cases);
    while(cases--) {
        readGraph();
        if(topoSort())
            printf("Case %d: Yes\n", ++casenum);
        else
            printf("Case %d: No\n", ++casenum);
    }

    return 0;
}

```